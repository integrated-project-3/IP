{"remainingRequest":"C:\\Users\\chris\\Desktop\\aileron\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\chris\\Desktop\\aileron\\node_modules\\eslint-loader\\index.js??ref--18-0!C:\\Users\\chris\\Desktop\\aileron\\src\\main.js","dependencies":[{"path":"C:\\Users\\chris\\Desktop\\aileron\\src\\main.js","mtime":1522176398702},{"path":"C:\\Users\\chris\\Desktop\\aileron\\package.json","mtime":1522176194972},{"path":"C:\\Users\\chris\\Desktop\\aileron\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1520545180302},{"path":"C:\\Users\\chris\\Desktop\\aileron\\node_modules\\babel-loader\\lib\\index.js","mtime":1519636541000},{"path":"C:\\Users\\chris\\Desktop\\aileron\\node_modules\\eslint-loader\\index.js","mtime":1519638534000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.promise\";\nimport Vue from 'vue/dist/vue.js';\nimport app from './app.vue';\nimport BootstrapVue from 'bootstrap-vue';\nimport VueRouter from 'vue-router';\nimport 'bootstrap/dist/css/bootstrap.css';\nimport 'bootstrap-vue/dist/bootstrap-vue.css';\nimport Vuex from 'vuex';\nimport createPersistedState from 'vuex-persistedstate';\nimport router from './router';\nimport InstantSearch from 'vue-instantsearch';\nimport { getAll, createTimeline as _createTimeline, deleteTimeline as _deleteTimeline, changeTimelineTitle as _changeTimelineTitle, createEvent, linkEventToTimeline, unlinkEventFromEvent, linkEventToEvent } from './scripts/api';\nVue.use(BootstrapVue);\nVue.use(VueRouter);\nVue.use(Vuex);\nVue.use(InstantSearch);\nVue.config.productionTip = false;\nvar timelines = [];\nvar store = new Vuex.Store({\n  state: {\n    timelines: timelines,\n    currentTimeline: null\n  },\n  mutations: {\n    addTimeline: function addTimeline(state, timeline) {\n      state.timelines.push(timeline);\n    },\n    addEvent: function addEvent(state, event) {\n      state.currentTimeline.timelineEvents.push(event);\n    },\n    removeTimeline: function removeTimeline(state, id) {\n      for (var i = 0; i < state.timelines.length; i++) {\n        if (state.timelines[i].id === id) {\n          state.timelines.splice(i, 1);\n          return;\n        }\n      }\n    },\n    setCurrentTimeline: function setCurrentTimeline(state, timeline) {\n      state.currentTimeline = timeline;\n    },\n    updateTimelineTitle: function updateTimelineTitle(state, payload) {\n      for (var i = 0; i < state.timelines.length; i++) {\n        if (state.timelines[i].id === payload.id) {\n          state.timelines[i].title = payload.title;\n          return;\n        }\n      }\n    }\n  },\n  actions: {\n    createTimeline: function createTimeline(_ref, title) {\n      var commit = _ref.commit;\n      return new Promise(function (resolve) {\n        _createTimeline(title).then(function (response) {\n          var item = response.data;\n          var timeline = {\n            title: item.Title,\n            date: item.CreationTimeStamp,\n            isDeleted: item.IsDeleted,\n            id: item.Id,\n            selected: false,\n            _rowVariant: ''\n          };\n          timeline.timelineEvents = [];\n          commit('addTimeline', timeline);\n          resolve(timeline);\n        });\n      });\n    },\n    deleteTimeline: function deleteTimeline(_ref2, id) {\n      var commit = _ref2.commit;\n\n      _deleteTimeline(id).then(function () {\n        commit('removeTimeline', id);\n      });\n    },\n    deleteSelectedTimelines: function deleteSelectedTimelines(_ref3) {\n      var state = _ref3.state;\n\n      /*\n        Filter returns an array of all selected timelines.\n        Foreach loops through that returned array,\n        using 'e' as the current timline.\n        Dispatch calls deleteTimeline action.\n        This at the end allows the use of this inside the forEach function.\n      */\n      state.timelines.filter(function (t) {\n        return t.selected;\n      }).forEach(function (e) {\n        this.dispatch('deleteTimeline', e.id);\n      }, this);\n    },\n    changeTimelineTitle: function changeTimelineTitle(_ref4, title) {\n      var commit = _ref4.commit;\n      var id = this.getters.selectedTimelines[0].id;\n\n      _changeTimelineTitle(id, title).then(function () {\n        commit('updateTimelineTitle', {\n          id: id,\n          title: title\n        });\n      });\n    },\n    createEventExact: function createEventExact(_ref5, payload) {\n      var state = _ref5.state,\n          commit = _ref5.commit;\n      var newEvent = {};\n      createEvent(payload).then(function (response) {\n        newEvent = response.data;\n        newEvent.LinkedTimelineEventIds = [];\n        linkEventToTimeline(newEvent.Id, state.currentTimeline.id).then(function () {\n          commit('addEvent', newEvent);\n        });\n      });\n    },\n    createEventBA: function createEventBA(_ref6, payload) {\n      var state = _ref6.state,\n          commit = _ref6.commit;\n      var newEvent = {};\n      createEvent(payload).then(function (response) {\n        newEvent = response.data;\n        linkEventToTimeline(newEvent.Id, state.currentTimeline.id).then(function () {\n          if (payload.beforeAfter === 'before') {\n            /*\n              Create a new timeline, create Event 1 at 12:00.\n              Create Event 2 set as before Event 1.\n              Now if you create Event 3 and also set this as before Event 1,\n              this will find that Event 2 already has a link to Event 1.\n              Replaces Event 2's link to Event 1 with a link to Event 3.\n              Links Event 3 to Event 1.\n              index would be the index of Event 2 in that example\n            */\n            var index = state.currentTimeline.timelineEvents.map(function (e) {\n              if (e.LinkedTimelineEventIds != null) if (e.LinkedTimelineEventIds[0] != null) return e.LinkedTimelineEventIds[0];\n            }).indexOf(payload.eventId);\n\n            if (index != -1) {\n              unlinkEventFromEvent(state.currentTimeline.timelineEvents[index].Id, payload.eventId);\n              linkEventToEvent(state.currentTimeline.timelineEvents[index].Id, newEvent.Id);\n              state.currentTimeline.timelineEvents[index].LinkedTimelineEventIds[0] = newEvent.Id;\n            }\n\n            linkEventToEvent(newEvent.Id, payload.eventId).then(function () {\n              newEvent.LinkedTimelineEventIds = [];\n              newEvent.LinkedTimelineEventIds.push(payload.eventId);\n              commit('addEvent', newEvent);\n            });\n          } else if (payload.beforeAfter === 'after') {\n            var _index = state.currentTimeline.timelineEvents.map(function (e) {\n              return e.Id;\n            }).indexOf(payload.eventId);\n\n            var item = state.currentTimeline.timelineEvents[_index];\n\n            if (item.LinkedTimelineEventIds != null) {\n              if (item.LinkedTimelineEventIds[0] != null) {\n                unlinkEventFromEvent(item.Id, item.LinkedTimelineEventIds[0]);\n                linkEventToEvent(newEvent.Id, item.Id);\n              }\n            }\n\n            linkEventToEvent(item.Id, newEvent.Id).then(function () {\n              item.LinkedTimelineEventIds = [];\n              item.LinkedTimelineEventIds.push(newEvent.Id);\n              commit('addEvent', newEvent);\n            });\n          }\n        });\n      });\n    }\n  },\n  getters: {\n    selectedTimelines: function selectedTimelines(state) {\n      return state.timelines.filter(function (t) {\n        return t.selected;\n      });\n    }\n  },\n  plugins: [createPersistedState({\n    paths: ['currentTimeline']\n  })]\n});\nnew Vue({\n  render: function render(h) {\n    return h(app);\n  },\n  router: router,\n  store: store,\n  methods: {\n    fetchTimelines: function fetchTimelines() {\n      timelines.splice(0, timelines.length);\n      var get = getAll();\n      get.then(function (data) {\n        for (var i = 0; i < data.data.Timelines.length; i++) {\n          var item = data.data.Timelines[i];\n          var timeline = {\n            title: item.Title,\n            date: item.CreationTimeStamp,\n            isDeleted: item.isDeleted,\n            id: item.Id,\n            timelineEvents: item.TimelineEvents,\n            selected: false,\n            _rowVariant: ''\n          };\n          timelines.push(timeline);\n        }\n      });\n    }\n  },\n  mounted: function mounted() {\n    this.fetchTimelines();\n  }\n}).$mount('#app');",{"version":3,"sources":["src\\main.js"],"names":["Vue","app","BootstrapVue","VueRouter","Vuex","createPersistedState","router","InstantSearch","getAll","createTimeline","deleteTimeline","changeTimelineTitle","createEvent","linkEventToTimeline","unlinkEventFromEvent","linkEventToEvent","use","config","productionTip","timelines","store","Store","state","currentTimeline","mutations","addTimeline","timeline","push","addEvent","event","timelineEvents","removeTimeline","id","i","length","splice","setCurrentTimeline","updateTimelineTitle","payload","title","actions","commit","Promise","resolve","then","item","response","data","Title","date","CreationTimeStamp","isDeleted","IsDeleted","Id","selected","_rowVariant","deleteSelectedTimelines","filter","t","forEach","e","dispatch","getters","selectedTimelines","createEventExact","newEvent","LinkedTimelineEventIds","createEventBA","beforeAfter","index","map","indexOf","eventId","plugins","paths","render","h","methods","fetchTimelines","get","Timelines","TimelineEvents","mounted","$mount"],"mappings":"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","file":"C:\\Users\\chris\\Desktop\\aileron\\src\\main.js","sourceRoot":"C:\\Users\\chris\\Desktop\\aileron","sourcesContent":["import Vue from 'vue/dist/vue.js'\nimport app from './app.vue'\nimport BootstrapVue from 'bootstrap-vue'\nimport VueRouter from 'vue-router'\nimport 'bootstrap/dist/css/bootstrap.css'\nimport 'bootstrap-vue/dist/bootstrap-vue.css'\nimport Vuex from 'vuex'\nimport createPersistedState from 'vuex-persistedstate'\nimport router from './router'\nimport InstantSearch from 'vue-instantsearch';\nimport {getAll, createTimeline, deleteTimeline, changeTimelineTitle, createEvent, linkEventToTimeline, unlinkEventFromEvent, linkEventToEvent} from './scripts/api'\n\nVue.use(BootstrapVue)\nVue.use(VueRouter)\nVue.use(Vuex)\nVue.use(InstantSearch)\n\nVue.config.productionTip = false\n\nvar timelines = []\n\nconst store = new Vuex.Store({\n  state: {\n    timelines,\n    currentTimeline: null\n  },\n  mutations: {\n    addTimeline (state, timeline) {\n      state.timelines.push(timeline)\n    },\n    addEvent(state, event) {\n      state.currentTimeline.timelineEvents.push(event)\n    },\n    removeTimeline(state, id) {\n      for (var i = 0; i < state.timelines.length; i++) {\n        if (state.timelines[i].id === id) {\n          state.timelines.splice(i,1)\n          return\n        }\n      }\n    },\n    setCurrentTimeline(state, timeline) {\n      state.currentTimeline = timeline\n    },\n    updateTimelineTitle(state, payload) {\n      for (var i = 0; i < state.timelines.length; i++) {\n        if (state.timelines[i].id === payload.id) {\n          state.timelines[i].title = payload.title\n          return\n        }\n      }\n    }\n  },\n  actions: {\n    createTimeline ({ commit }, title) {\n      return new Promise ((resolve) => {\n        createTimeline(title).then(response => {\n          var item = response.data\n          var timeline = {\n           title: item.Title,\n           date: item.CreationTimeStamp,\n           isDeleted: item.IsDeleted,\n           id: item.Id,\n           selected: false,\n           _rowVariant: ''\n        }\n          timeline.timelineEvents = []\n          commit('addTimeline', timeline)\n          resolve(timeline)\n        })\n      })\n    },\n    deleteTimeline({ commit }, id) {\n      deleteTimeline(id).then(() => {\n        commit('removeTimeline', id)\n      })\n    },\n    deleteSelectedTimelines({ state }) {\n      /*\n        Filter returns an array of all selected timelines.\n        Foreach loops through that returned array,\n        using 'e' as the current timline.\n        Dispatch calls deleteTimeline action.\n        This at the end allows the use of this inside the forEach function.\n      */\n      state.timelines.filter(t => t.selected).forEach(function(e){this.dispatch('deleteTimeline',e.id)}, this)\n    },\n    changeTimelineTitle({ commit }, title) {\n      var id = this.getters.selectedTimelines[0].id\n      changeTimelineTitle(id, title).then(() => {\n        commit('updateTimelineTitle', {id, title})\n      })\n    },\n    createEventExact ({state, commit}, payload) {\n      var newEvent = {}\n      createEvent(payload).then(response => {\n        newEvent = response.data\n        newEvent.LinkedTimelineEventIds = []\n        linkEventToTimeline(newEvent.Id, state.currentTimeline.id).then(() => {\n          commit('addEvent', newEvent)\n        })\n      })\n    },\n    createEventBA({state, commit}, payload) {\n      var newEvent = {}\n      createEvent(payload).then(response => {\n        newEvent = response.data\n        linkEventToTimeline(newEvent.Id, state.currentTimeline.id).then(() => {\n          if (payload.beforeAfter === 'before') {\n            /*\n              Create a new timeline, create Event 1 at 12:00.\n              Create Event 2 set as before Event 1.\n              Now if you create Event 3 and also set this as before Event 1,\n              this will find that Event 2 already has a link to Event 1.\n              Replaces Event 2's link to Event 1 with a link to Event 3.\n              Links Event 3 to Event 1.\n              index would be the index of Event 2 in that example\n            */\n            let index = state.currentTimeline.timelineEvents.map(function(e) {if(e.LinkedTimelineEventIds != null)if(e.LinkedTimelineEventIds[0] != null)return e.LinkedTimelineEventIds[0]}).indexOf(payload.eventId)\n            if (index != -1) {\n              unlinkEventFromEvent(state.currentTimeline.timelineEvents[index].Id, payload.eventId)\n              linkEventToEvent(state.currentTimeline.timelineEvents[index].Id, newEvent.Id)\n              state.currentTimeline.timelineEvents[index].LinkedTimelineEventIds[0] = newEvent.Id\n            }\n            linkEventToEvent(newEvent.Id, payload.eventId).then(() => {\n              newEvent.LinkedTimelineEventIds = []\n              newEvent.LinkedTimelineEventIds.push(payload.eventId)\n              commit('addEvent', newEvent)\n            })\n          } else if (payload.beforeAfter === 'after') {\n            let index = state.currentTimeline.timelineEvents.map(function(e) {return e.Id}).indexOf(payload.eventId)\n            let item = state.currentTimeline.timelineEvents[index]\n            if (item.LinkedTimelineEventIds != null) {\n              if (item.LinkedTimelineEventIds[0] != null) {\n                unlinkEventFromEvent(item.Id, item.LinkedTimelineEventIds[0])\n                linkEventToEvent(newEvent.Id, item.Id)\n              }\n            }\n            linkEventToEvent(item.Id, newEvent.Id).then(() => {\n              item.LinkedTimelineEventIds = []\n              item.LinkedTimelineEventIds.push(newEvent.Id)\n              commit('addEvent', newEvent)\n            })\n          }\n        })\n      })\n    }\n  },\n  getters: {\n    selectedTimelines: (state) => {\n      return state.timelines.filter(t => t.selected)\n    }\n  },\n  plugins: [createPersistedState({\n    paths: ['currentTimeline']\n })]\n})\n\nnew Vue({\n  render: h => h(app),\n  router,\n  store,\n  methods: {\n    fetchTimelines() {\n      timelines.splice(0, timelines.length)\n      var get = getAll()\n      get.then((data) => {\n        for (var i = 0; i < data.data.Timelines.length; i++) {\n          var item = data.data.Timelines[i]\n          var timeline = {\n             title: item.Title,\n             date: item.CreationTimeStamp,\n             isDeleted: item.isDeleted,\n             id: item.Id,\n             timelineEvents: item.TimelineEvents,\n             selected: false,\n             _rowVariant: ''\n          }\n          timelines.push(timeline)\n        }\n      })\n    }\n  },\n  mounted() {\n    this.fetchTimelines()\n  }\n}).$mount('#app')\n"]}]}